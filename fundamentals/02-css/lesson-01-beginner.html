<!DOCTYPE html>

<html lang="en">
<head>
  <!-- CHARACTER ENCODING & VIEWPORT FIRST -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- PRIMARY METADATA -->
  <title>CSS Basics</title>
  <meta name="description" content="An Introduction to CSS Basics for Complete Beginners">
  <meta name="author" content="Wasula Benjamin">

  <!-- SEO AND INDEXING -->
  <meta name="robots" content="index, follow">
  <meta name="keywords" content="web development basics, css, css3, introduction, basic css">

  <!-- OPEN GRAPH/SOCIAL METADATA (SHOULD COME BEFORE ICONS)  -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://github.com/wasulabenjamin/web-basics">
  <meta property="og:title" content="CSS Basics">
  <meta property="og:description" content="An Introduction to CSS Basics for Complete Beginners">
  <meta property="og:image" content="../../assets/img/social-media.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="628">
  <meta property="og:image:alt" content="CSS Basics Infographic">
  <meta property="og:site_name" content="Wasula Benjamin">

  <!-- TWITTER CARD TAGS -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="CSS Basics">
  <meta name="twitter:description" content="An Introduction to CSS Basics for Complete Beginners">
  <meta name="twitter:image" content="../../assets/img/social-media.png">
  <meta name="twitter:image:alt" content="CSS Basics Infographic">
  <meta name="twitter:site" content="@wasulabenjamin">
  <meta name="twitter:creator" content="@wasulabenjamin">
  <meta name="twitter:domain" content="github.com/wasulabenjamin/web-basics">

  <!-- PWA SUPPORT AND BROWSER UI ENHANCEMENTS -->
  <meta name="theme-color" content="#fafafa"> <!-- fallback default for older browsers -->
  <link rel="manifest" href="../../site.webmanifest">

  <!-- ICONS (ORDER MATTERS FOR FALLBACK) -->
  <link rel="icon" href="../../icon.svg" type="image/svg+xml">
  <link rel="icon" href="../../icon.png" type="image/png">
  <link rel="icon" href="../../favicon.ico" type="image/x-icon" sizes="any">
  <link rel="apple-touch-icon" href="../../icon.png">

  <!-- STYLESHEETS: LOCAL FIRST  -->
  <link rel="stylesheet" href="../../assets/css/learn-css.css">
</head>
<body>

	<header>
		<h1>LESSON 01: BEGINNER</h1>
	</header>

	<main>
		<!--
    CSS Tutorial.
    This CSS tutorial covers everything from basic styling concepts and selectors to advanced techniques, such as
    flexbox, grid, animations, and CSS variables. This CSS tutorial is designed to help both beginners and experienced
    designers to make them masters in creating visually appealing, responsive, and modern web designs.

    What is CSS?
    CSS is the acronym for "Cascading Style Sheet". It's a style sheet language used for describing the presentation
    of a document written in a markup language like HTML. CSS helps the web developers to control the layout and other
    visual aspects of the web pages. CSS plays a crucial role in modern web development by providing the tools
    necessary to create visually appealing, accessible, and responsive websites.

    Since the start of CSS, several versions have come into existence. Some of the notable versions include:
      - CSS1 (Cascading Style Sheets Level 1):
        The initial version of CSS, released in December 1996. CSS1 provided basic styling capabilities for HTML
        documents, including properties for text, colors, backgrounds, margins, and borders.
      - CSS2 (Cascading Style Sheets Level 2):
        Released in May 1998, CSS2 introduced new features such as positioning, z-index, media types, and more
        advanced selectors like attribute selectors and child selectors.
      - CSS2.1 (Cascading Style Sheets Level 2.1):
        This version 2.1, published as a W3C Recommendation in June 2011, clarified and refined CSS2, addressing
        inconsistencies and ambiguities in the specification. CSS2.1 focused on improving interoperability among web
        browsers.
      - CSS3 (Cascading Style Sheets Level 3:
        CSS3 is a collection of modules that extend the capabilities of CSS. It introduces many new features and
        enhancements, including advanced selectors, multiple column layouts, animations, transformations, gradients,
        shadows, and more.
      - CSS4 (Cascading Style Sheets Level 4:
        CSS4 is an ongoing effort to extend CSS3 with new features and enhancements.

    Each version of CSS builds upon the previous ones, adding new features and refining existing capabilities to meet
    the evolving needs of web developers and designers. CSS is referred to as just CSS now, without a version number.

    Types of CSS.
      - Inline CSS: Applied directly to an HTML element using the style attribute.
              It has the highest priority among the three methods.
      - Internal CSS: IDefined within the <style> tag inside the <head> section of an HTML document.
      - External CSS: Written in a separate .css file and linked to the HTML document using the <link> tag.
              This is the recommended method for large projects as it improves maintainability.

    Advantages of Using CSS.
      - Responsive design: CSS offers features like media queries that enable developers to create responsive layouts
        that adapt to different screen sizes and devices, ensuring a consistent user experience.
      - Flexibility and Control: CSS provides precise control over the presentation of HTML elements, allowing
        developers to customize layout, typography, colors, and other visual properties.
      - Consistency and Reusability: Developers ensure consistency across the entire website by defining styles in a
        central CSS file. Styles can be reused across multiple pages, reducing redundancy and making updates easier.
      - Search Engine Optimization (SEO) - CSS can be used to structure content in a way that improves search engine
        visibility.
      - Ease of Maintenance: Centralized CSS files make it easier to maintain and update styles across a website.
        Changes can be applied globally, ensuring uniformity and reducing the risk of inconsistencies.
      - Faster Page Loading: External CSS files can be cached by browsers, resulting in faster page loading times for
        later visits to a website. This caching mechanism reduces server load and bandwidth consumption.

    Components of CSS.
    CSS works by associating rules with HTML elements. A CSS rule contains two main parts:
    - a selector which specifies the HTML element(s) to style.
    - a declaration block which contains one or more declarations separated by semicolons.
      Each declaration includes a property-name and value, specifying the aspect of the element presentation to control.
		-->
		<section class="home">
			<h1>Home</h1>
			<div>
				<h1>Hello World</h1>
				<p>This is a sample CSS Code!</p>
			</div>
		</section><hr>

		<!--
    What is CSS?
    CSS stands for Cascading Style Sheets, used to describe the presentation and design of web pages.
    Using CSS, you can control the color of the text, the style of fonts, the spacing between paragraphs, how columns
    are sized and laid out, what background images or colors are used.
    CSS can control the layout of multiple web pages all at once.

    Why Use CSS?
    - CSS Saves Time: You can write CSS once and then reuse the same styles across multiple HTML pages.
    - Pages Load Faster: If you are using CSS, you do not need to write HTML tag or attributes every time.
      Just write one CSS rule of a tag and apply it to all the occurrences of that tag.
    - Easy Maintenance: To make a global change, simply change the style, and all elements in all the web pages will be
      updated automatically.
    - Superior Styles to HTML: CSS has a much wider array of attributes than HTML,
      so you can get a far better look to your HTML page.
    - Multiple Device Compatibility: For the same HTML document, different versions of a website can be presented for
      different screen widths
    - Global Web Standards: Now that most HTML attributes are being deprecated, it is recommended to use CSS.

    CSS Syntax consists of selectors and declaration used to apply styles to HTML elements.
      selector {
        property: value;
      }

    The selector targets the HTML element(s) that you want to style.
    The declaration block contains one or more declarations enclosed in curly braces {}.
    Each declaration consists of a property and a value separated by a colon:
    Semicolons(;) separate declarations

    There are several types of selectors available in CSS, commonly used selectors are classes, IDs and tags.
    To know the complete list of selectors, visit the CSS Selectors article.

    CSS History and Versions
    Current version of CSS is CSS3.Early versions were CSS1 and CSS2.
    As of now, CSS is continuously evolving and adapting new capabilities that fulfill current websites' requirements.

    --------------------------------------------------------------------------------------------------------------------

    CSS Syntax.
    CSS syntax consists of selectors and declaration used to apply styles to HTML elements.
      selector {
        property: value;
      }

    Selector: CSS selectors are used to select the HTML element or groups of elements you want to style on a web page.
    Property: An aspect or characteristic of an HTML element that can be styled or modified using CSS,
              such as color, font-size, or margin.
    Value:    Values are assigned to properties.
              For example, color property can have value like red, green, e.t.c.

    Multiple Style Rules
    If you want to define multiple rules for a single selector, you can specify those in a single block separated by a
    semicolon (;).
      selector{
        property1: value1;
        property2: value2;
        property3: value3;
      }

    CSS Selectors Syntax.
    CSS Selectors are used to select the HTML elements you want to style on a web page.
    They allow you to target specific elements or groups of elements to apply styles like colors, fonts, margins, etc.

    Different types of selectors are mentioned below:
      - Universal Selector........ Select and apply styles to all elements in an HTML document.
      - Element Selectors......... Select specific HTML elements.
      - Class Selectors........... Select and style an element with a specific value for its class attribute.
      - Id Selectors.............. Select a single element with a particular value for the id attribute.
      - Attribute Selectors....... Select an element based on a specific attribute value.
      - Pseudo-Element Selector... Selects and styles specific parts of an element.
      - Pseudo-Class Selector..... Selects and styles elements based on their state.

    CSS Inclusion Syntax.
    CSS can be used in any HTML document using three different methods which are: inline, internal, and external CSS.
      - Inline CSS Syntax.
        <div style="color: #04af2f;">Welcome to TutorialsPoint.</p>

      - Internal CSS Syntax.
        Internal CSS is used within the head section of an HTML document using a style tag.
            <style>
              body {
                background-color: #04af2f;
              }
            </style>

      - External CSS Syntax.
        External CSS is written in a separate .css file and linked to the HTML document using a link tag.
            <link rel="stylesheet" type="text/css" href="style.css">

    CSS Media Queries Syntax.
    CSS media queries apply different CSS styles based on the screen size, resolution, and other characteristics
    and are often used for creating responsive designs.
      @media (max-width: 700px) {
        body {
          background-color: #04af2f;
        }
      }

    CSS Variables Syntax
    CSS Variables allows storing and reusing values throughout the CSS program.
      root {
        --main-color: #04af2f;
      }

    CSS Comments Syntax
    CSS comments add an explanatory note about the code.
      /* This is a single line CSS comment */

    --------------------------------------------------------------------------------------------------------------------

    CSS - Comments
    Comments are useful in adding explanatory notes or annotations within your style-sheet that are not interpreted as
    styling instructions by the web browser.
    CSS comments are intended for the benefit of developers and are ignored by the browser when rendering a web page.
    They are useful in documentation, debugging, etc.

    In CSS, there are two main ways to create comments:
      - Single-line Comments: Single-line comments are created using /* to start the comment and */ to end it.
      - Multi-line Comments: Multi-line comments allow you to add comments that span multiple lines.
        They are also enclosed within /* and */.
		-->
		<section class="syntax">
			<h1>Syntax</h1>
      <p>This is a normal paragraph</p>
      <p class="special">This is a special paragraph</p>
		</section><hr>

		<!--
    Inline CSS.
    Inline CSS is applied directly to an HTML element using the style attribute.
    It has the highest priority among the three methods.
      SYNTAX: <element style = "...style rules....">

    Internal CSS.
    Internal CSS is defined within the <style> tag inside the <head> section of an HTML document.

    External CSS.
    External CSS is written in a separate .css file and linked to the HTML document using the <link> tag.
    This is the recommended method for large projects as it improves maintainability.

    --------------------------------------------------------------------------------------------------------------------

    CSS Inclusion
    You need to include the CSS file in your HTML document before using it.
    There are multiple ways to include CSS in an HTML file: inline CSS, internal CSS, or including a CSS file.

    Styles can be associated with your HTML document in different ways, such as
      - Inline CSS Syntax.
        <div style="color: #04af2f;">Welcome to TutorialsPoint.</p>

      - Internal CSS Syntax.
        Internal CSS is used within the head section of an HTML document using a style tag.
            <style type="text/css">
                body {
                    background-color: #04af2f;
                }
            </style>

        Attributes associated with <style> elements are:−
          * type.... text/css
                     Specifies style-sheet language as a content-type (MIME type). This is a required attribute.
          * media... screen/tty/tv/projection/handheld/print/braille/aural/all
                     Specifies the device the document will be displayed on.
                     Default value is all. This is an optional attribute.

      - External CSS Syntax.
        External CSS is written in a separate .css file and linked to the HTML document using a link tag.
          <link rel="stylesheet" type="text/css" href="style.css">

        Attributes associated with <style> elements are:−
          * type.... text/css
          * media... screen/tty/tv/projection/handheld/print/braille/aural/all
          * href.... URL
                     Specifies the style sheet file having style rules. This attribute is required.
                     Specifies the device the document will be displayed on.
                     Default value is all. This is an optional attribute.

    Imported CSS - @import Rule
    The @import is used to import an external style-sheet in a manner similar to the <link> element.
    By using @import rule, one style-sheet can be imported into another style-sheet.
    The only key point to remember is, the @import rule must be declared on top of the document.

      SYNTAX: Refer the following two CSS files; style.css and demostyle.css

      style.css
      body {
         background-color: peachpuff;
      }

      demostyle.css
      @import url("style.css");
      h1 {
            color: #36CFFI;
         }
      p {
            font-size: 1.5em;
            color: white
      }
      div {
            border: 5px inset gold;
            background-color: black;
            width: 300px;
            text-align: center
      }

      You just need to include the stylesheet that has @import rule defined in the <link> tag in the HTML document
      as follows −

      <head>
        ...
        <link type = "text/css" href = "demostyle.css">
      </head>

    CSS Rules Overriding.
    We have discussed different ways to include style sheet rules in an HTML document.
    Here is the rule to override any Style Sheet Rule.

      - Any inline style sheet takes the highest priority.
        So, it will override any rule defined in <style>...</style> tags or any external style sheet file.
      - Any rule defined in <style>...</style> tags will override rules defined in any external style sheet file.
      - Any rule defined in an external stylesheet file takes the lowest priority,
        and rules defined in this file will be applied only when the above two rules are not applicable.
      - Not forgetting, external stylesheets load in order, and the last loaded override earlier ones
      - Specificity overrides order:
            #id beats .class, which beats element
            div#hero h1 is more specific than just h1
      - !important overrides everything (but should be used sparingly as it breaks the natural cascade)

    CSS Comments Inclusion
    Many times, you may need to put additional comments in your style sheet blocks.
    So, it is very easy to comment on any part in the stylesheet.
    You can simply put your comments inside /* ...this is a comment in the stylesheet... */
    You can use /* ... */ to comment multi-line blocks.
		-->
		<section class="types">
			<h1>Types</h1>

      <h2>Inline CSS</h2>
      <p style="color: red; font-family: Verdana, sans-serif;">This line is an inline-styled paragraph</p>
      <br>

      <h2>Internal CSS</h2>
      <!--suppress HtmlUnknownTag -->
      <style>
        .internal-css {
          color: green; font-family: Verdana, sans-serif;
        }
      </style>
      <p class="internal-css">This line is an internal-styled paragraph</p>
      <br>

      <h2>Internal CSS</h2>
      <p class="external-css">This line is an external-styled paragraph</p>

		</section><hr>

		<!--
    CSS - Units
    CSS Units define the measurement system used to specify the values.
    CSS offers a number of different units for expressing length and measurement.
    CSS unit is used to specify the property size for a page element or its content.

    There are a number of ways to specify and measure length in CSS.
    It is used to specify margins, padding, font size, width, height, border, etc.

    For example - font-size: 50px, here number 50 has a suffix px i.e., pixel, it is a CSS measurement unit.

    There should be no whitespace between the number and the unit. The unit can be left out when the value is 0.

    Length Units.
    Length units can be categorized into two types:
      - Absolute units: Fixed unit lengths that do not depend on screen width.
      - Relative units: Responsive unit lengths that change, according to screen width.

    Absolute Length Units.
    These units are categorized as fixed-length units, which means that lengths specified with absolute units maintain
    an exact, unchanged size on the screen.

    These units prove to be very effective when the browser has comprehensive information about the properties of the
    screen, the printer being used, or other appropriate user agents.

    The following are all the types of absolute units:
      - mm....... Refers to millimeter, it is used to specify the measurements in millimeters.
                  1mm = 1/10th of 1cm
      - cm....... Refers to centimeter, it is used to specify the measurements in centimeters.
                  1cm = 37.8px = 25.2/64in
      - Q........ Refers to Quarter-millimeters, it is used to specify the measurements in centimeters.
                  1Q = 1/40th of 1cm
      - in....... Refers to inches, it is used to specify the measurement in inches.
                  1in = 2.54cm = 96px
      - pt....... Refers to point, it is used to specify the measurements in points.
                  1pt = 1/72 of 1in
      - pc....... Refers to picas, it is used to specify the measurement in picas.
                  1pc = 1/6th of 1in
      - px....... Refers to pixels, it is used to specify the measurement in pixels.
                  1px = 1/96th of 1in
      - em....... Relative to the font-size of the element.
      - ex....... Relative to the x-height of the current font.
      - ch....... Relative to the width of the "0".
      - rem...... Relative to the font-size of the root element.
      - lh....... Relative to the line height of the element.
      - rlh...... t is relative to the line height of the root element.

    Absolute units prove valuable for projects where responsiveness is not a priority.
    However, they are less beneficial for responsive websites because they do not adjust when screen dimensions change.

    Relative Length Units.
    Relative length units are measured in relation to other elements or viewport of the screen.
    Relative units are great for styling responsive websites because they can be adjusted proportionally based on
    window size or parent elements. These units define lengths relative to other length properties.

    The following are all the types of relative units:

    vb.......... Relative to the size of the initial containing block in the direction of the root element block axis.
                 1vb = 1% of the containing block's size (block axis).
    vh.......... Relative to the height of the viewport.
                 1vh = 1% or 1/100 of the height of the viewport.
    vw.......... Relative to the width of the viewport.
                 1vw = 1% or 1/100 of the width of viewport.
    vi.......... Relative to the size of the initial containing block in the direction of the root element inline axis.
                 1vb = 1% of the containing block's size (inline axis).
    dvw, dvh.... Relative to the width and height of the dynamic viewport.
                 1dvw = 1% or 1/100 of the dynamic viewport's width
                 1dvh = 1% or 1/100 of the dynamic viewport's height.
    svw, svh.... Relative to the width and height of the smaller viewport.
                 1svw = 1% or 1/100 of the smaller viewport's width
                 1svh = 1% or 1/100 of the smaller viewport's height.
    lvw, lvh.... Relative to the width and height of the larger viewport.
                 1lvw = 1% or 1/100 of the larger viewport's width
                 1lvh = 1% or 1/100 of the larger viewport's height.
    vmin........ Relative to the smaller dimension of the viewport.
                 1vmin = 1% or 1/100 of the viewport's smaller dimension.
    vmax........ Relative to the larger dimension of the viewport.
                 1vmax = 1% or 1/100 of the viewport's larger dimension.
		-->
		<section class="measurement-units">
			<h1>Measurement Units</h1>

      <h2>Absolute Units</h2>
      <p class="absolute-unit-mm">Font size as 5mm</p>
      <p class="absolute-unit-cm">Font size as 1cm</p>
      <p class="absolute-unit-q">Font size as 40Q</p>
      <p class="absolute-unit-in">Font size as .167in</p>
      <p class="absolute-unit-pt">Font size as 12pt</p>
      <p class="absolute-unit-pc">Font size as 1pc</p>
      <p class="absolute-unit-px">Font size as 16px</p>
      <p class="absolute-unit-em">Font size as 4em</p>
      <p class="absolute-unit-ex">Font size as 4ex</p>
      <p class="absolute-unit-ch">Font size as 4ch</p>
      <p class="absolute-unit-rem">Font size as 4rem</p>
      <p class="absolute-unit-lh">Font size as 4lh</p>
      <p class="absolute-unit-rlh">Font size as 4rlh</p>

      <h2>Relative Units</h2>
      <h3>By Height</h3>
      <p class="relative-unit-vb">Font size as 4vb</p>
      <p class="relative-unit-vh">Font size as 4vh</p>
      <p class="relative-unit-dvh">Font size as 4dvh</p>
      <p class="relative-unit-lvh">Font size as 4lvh</p>
      <p class="relative-unit-svh">Font size as 4svh</p>

      <h3>By Width</h3>
      <p class="relative-unit-vi">Font size as 4vi</p>
      <p class="relative-unit-vw">Font size as 4vw</p>
      <p class="relative-unit-dvw">Font size as 4dvw</p>
      <p class="relative-unit-lvw">Font size as 4lvw</p>
      <p class="relative-unit-svw">Font size as 4svw</p>

      <h3>By Both</h3>
      <p class="relative-unit-vmin">Font size as 4vmin</p>
      <p class="relative-unit-vmax">Font size as 4vmax</p>
		</section><hr>

    <!--
    CSS - Selectors
    CSS Selectors are used to select the HTML elements you want to style on a web page.
    They allow targeting specific elements or groups of elements to apply styles like colors, fonts, margins, and more.
    The element or elements that are selected by the selector are referred to as a subject of the selector.

    CSS Nested Selectors
    CSS nesting allows nesting one style rule inside another rule, with the selector of the child rule relative to the
    selector of the parent rule. The nesting selector shows the relationship between the parent and child rules.
      - When the browser parses the nested selectors, it automatically adds whitespace between the selectors, thus
        creating a new CSS selector rule.
      - In situations where the nested rule needs to be attached to the parent rule (without any whitespace), like
        while using the pseudo-class or compound selectors, the umber-sand(&) nesting selector must be prepended
        immediately to achieve the desired result.
      - In order to reverse the context of rules, the umber-sand(&) nesting selector can be appended.
      - There can be multiple instances of the umber-sand(&) nesting selector.
    -->
		<section class="selectors">
			<h1>Selectors</h1>

      <!--
      CSS Universal Selector.
      CSS universal selector is a special selector that selects all the elements in an HTML document.
      It is denoted by an asterisk mark (*).
      The syntax for the universal selector is as follows:
        * {
          margin: 0;
          padding: 0;
        }
      As per the above syntax, the universal selector is used to apply a margin and padding of 0 to all HTML elements.
      -->
  		<article class="universal-selectors">
        <h2>Universal Selectors</h2>
        <p>Example paragraph to be styled by a Universal Selector</p>
        <div>Example div to be styled by a Universal Selector</div>
        <span>Example span to be styled by a Universal Selector</span>
      </article><br><br>

      <!--
      CSS Element Selector.
      CSS element selector selects and styles specific HTML elements.
      The element selector is defined by simply using the element's name in the stylesheet.
      The syntax for the element selector is as follows:
        p {
          color: green;
        }
      -->
  		<article class="element-selectors">
        <h2>Element Selectors</h2>
        <p>Example paragraph to be styled by an Element Selector</p>
        <div>Example div to be styled by an Element Selector</div>
        <span>Example span to be styled by an Element Selector</span>
      </article><br><br>

      <!--
      CSS Class Selector.
      CSS class selector selects an element with a specific class attribute.
      The class selector is defined using a period (.) followed by the class name.
      The syntax for the class selector is as follows:
        .class-name {
          property1: value1;
        }
      -->
  		<article class="class-selectors">
        <h2>Class Selectors</h2>
        <p class="cs">Example paragraph to be styled by a Class Selector</p>
        <div class="cs">Example div to be styled by a Class Selector</div>
        <span class="cs">Example span to be styled by a Class Selector</span>
        <br><br>

        <h3>Multiple Class Selectors</h3>
        <p class="bgc">This is a paragraph with background color will not be styled</p>
        <p class="bgc brd">This is a paragraph with background color and border will be styled</p>
        <br><br>

        <h3>Combining Class Selector with Other Selectors</h3>
        <p class="bgc">This is a paragraph with background color, it will not be styled</p>
        <p class="bgc brd">This is a paragraph with background color and border, it will be styled</p>
        <br><br>

        <h3>Combining Multiple Classes</h3>
        <p class="room bed">This is my bedroom paragraph</p>
        <p class="room lvg">This is my living-room paragraph</p>

        <h3>Using Class Selectors with Media Queries</h3>
        <p class="cs-mq">This will change color when the device width is less than 700px</p>
      </article><br><br>

      <!--
      CSS ID Selector
      CSS ID selector selects an element with a specific value for its id attribute.
      It is denoted by the "#" (hash) symbol.
      The syntax for the ID selector is as follows:
        #id-name {
          property1: value1;
        }
      -->
  		<article class="id-selectors">
        <h2>ID Selectors</h2>
        <p id="id1">Example paragraph to be styled by an ID Selector</p>
        <div id="id2">Example div to be styled by an ID Selector</div>
        <span id="id3">Example span to be styled by an ID Selector</span>
        <br><br>

        <h3>ID Selector with Hover Pseudo-Classes</h3>
        <p id="id4">Example paragraph to be styled by an ID Selector</p>

        <h3>Using ID Selector with Forms</h3>
        <form>
          <label for="user">Username:</label>
          <input type="text" id="user" name="username" placeholder="Enter your username">
          <br><br>
          <button type="submit" id="btn">Submit</button>
        </form>
      </article><br><br>

      <!--
      CSS Combinators.
      They specify a relationship between selectors so that styling can be done based on that relationship.
      In other words, combinators help focus on elements based on their position and hierarchy within the HTML document.
      For example, with combinators you can style a paragraph element placed immediately after a div element.

      POINTS TO REMEMBER. 💡

      `div p`   → children, grandchildren, everyone...
                  All `<p>` elements inside a `<div>`, no matter how deep.
                  Descendant combinator — space means “any level down.”

      `div > p` → only the direct kids.
                  Only `<p>` elements that are immediate children of `<div>`.
                  Child combinator — `>` means “one level below.”

      `div + p` → the next-door sibling only.
                  The first `<p>` that comes right after a `<div>`, sharing the same parent.
                  Adjacent sibling combinator — `+` means “immediately after.”

      `div ~ p` → all the younger siblings after.
                  Every `<p>` that comes after a `<div>`, under the same parent — not just the first.
                  General sibling combinator — `~` means “all that follow.”

      `col || td` → same column gang.
                  All `<td>` cells that belong to the same column as a `<col>` element.
                  Column combinator — `||` means “same column in table layout.”
      -->
      <article class="combinators">
        <h2>Combinators</h2>
        <p>Example paragraph to be styled by a Combinator</p>
        <div>Example div to be styled by a Combinator</div>
        <span>Example span to be styled by a Combinator</span>

        <!--
        CSS Descendant Combinator
        Used to select elements that are nested within another element, regardless of how deeply they are nested.
        These are often represented by a single space.
        -->
        <div class="descendant-combinator">
          <h3>CSS Descendant Combinator</h3>
          <div>
            <p>Paragraph 0 before heading</p>
            <h4>Some H4 Heading</h4>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
            <div>
              <p>Paragraph 3 inside another div</p>
            </div>
          </div>
        </div><br><br>

        <!--
        CSS Child Combinator
        The child combinator (>) is used to select elements that are direct children of a specified element.
        It will not select elements that are further nested inside the child elements.
        -->
        <div class="child-combinator">
          <h3>CSS Child Combinator > </h3>
          <div>
            <p>Paragraph 0 before heading</p>
            <h4>Some H4 Heading</h4>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
            <div>
              <p>Paragraph 3 inside another div</p>
            </div>
          </div>
        </div><br><br>

        <!--
        CSS Adjacent Sibling Combinator
        Adjacent sibling combinator (+) is used to select an element immediately preceded by a specified element.
        It only affects the element that directly follows the specified element.
        -->
        <div class="adjacent-sibling-combinator">
          <h3>CSS Adjacent Sibling Combinator + </h3>
          <div>
            <p>Paragraph 0 before heading</p>
            <h4>Some H4 Heading</h4>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
            <div>
              <p>Paragraph 3 inside another div</p>
            </div>
          </div>
        </div><br><br>

        <!--
        CSS General Sibling Combinator
        The general sibling combinator (~) is used to select all elements that are siblings of a specified element and
        appear after it in the HTML structure.
        It will select all matching siblings, not just the one immediately following.
        It will not select elements that are further nested inside the child elements.
        -->
        <div class="general-sibling-combinator">
          <h3>CSS General Sibling Combinator ~ </h3>
          <div>
            <p>Paragraph 0 before heading</p>
            <h4>Some H4 Heading</h4>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
            <div>
              <p>Paragraph 3 inside another div</p>
            </div>
          </div>
        </div><br><br>

        <!--
        Combining Multiple Combinators
        In CSS, you can combine multiple combinators to create more complex and specific selectors.
        By combining different combinators, you can specifically target the elements based on more complex relationships
        within the HTML structure.
        -->
        <div class="multiple-combinator">
          <h3>Combining Multiple Combinators</h3>
          <nav>
            <ul>
              <li><a href="#">Home</a></li>
              <li><a href="#">About</a></li>
              <li><a href="#">Services</a></li>
              <li><a href="#">Contact</a></li>
            </ul>
          </nav>
        </div><br><br>
      </article><br><br>

      <!--
      CSS Attribute Selector
      Attribute selectors allow you to select HTML elements based on the presence or value of one or more attributes.
      They are a powerful way to target specific elements in your HTML markup.
      Attribute selectors are enclosed in square brackets [] and can take various forms.
      The syntax for the attribute selector is as follows:
        a[target] {
          property1: value1;
        }

      The following sections discuss some common ways to use attribute selectors:
      - CSS [attribute] Selector.
        Selects elements that have specified attribute, regardless of its value.
      - CSS [attribute="value"] Selector.
        Selects elements that have a specific attribute with a specific value.
      - CSS [attribute*="value"] Selector.
        Selects elements that have a specific attribute with a value containing a specific substring anywhere within it.
      - CSS [attribute^="value"] Selector.
        Selects elements that have a specific attribute with a value that starts with a specific string.
      - CSS [attribute$="value"] Selector.
        Selects elements that have a specific attribute with a value that ends with a specific string.
      - CSS [attribute|="value"] Selector.
        Selects elements that have a specific attribute with a specific value OR the specific value followed by a hyphen
        This selector is often used for selecting elements with language-specific attributes,
        such as lang attributes, which often use hyphens to denote language subcodes.
        NOTE: IT MATCHES THE VALUE IF AND ONLY IF IT IS EXACTLY EQUAL TO VALUE OR STARTS WITH 'VALUE-'
              IF ANYTHING THAT FOLLOWS THE SUB-STRING IS NOT AN HYPHEN, IT WILL NOT MATCH
      - CSS [attribute~="value"] Selector
        This selector is used to select elements that have a specific attribute with a value containing a specified word.
        The word should be a standalone word, surrounded by spaces or at the beginning or end of the attribute value.

      IMPORTANT!
      For operators like =, ^=, $=, *=, |= the browser treats the whole attribute value as a single plain string,
      spaces and all. No matter how many names you may have for that attribute.
      The only selector that split by whitespace is [attr~=value]
      -->
      <article class="attr-selectors">
        <h2>Attr Selectors</h2>
        <a href="https://github.com/wasulabenjamin">GitHub</a>.
        <a href="#" target="_blank">Codacy</a>.
        <a href="#" target="_blank">LinkedIn</a>.
        <a href="#" target="_self">Behance</a>.
        <a href="#" target="_self">Dribble</a>.
        <br><br>

        <h3>CSS [attribute] Selector</h3>
        <div data-toggle="yes">An example div with a data-toggle attribute</div>
        <div>An example div without a data-toggle attribute</div>
        <p data-toggle="no">An example paragraph with a data-toggle attribute</p>
        <p>An example paragraph without a data-toggle attribute</p>
        <br><br>

        <h3>CSS [attribute="value"] Selector</h3>
        <label><input type="text" name="" placeholder="Enter Name"></label>
        <label><input type="password" name="" placeholder="Enter Password"></label>
        <br><br>

        <h3>CSS [attribute*="value"], [attribute^="value"], and [attribute$="value"] Selectors</h3>
        <a href="https://example.com/page0">Page-0</a>
        <a href="https://www.example.com/page1">Page-1</a>
        <a href="https://example.com/page2">Page-2</a>
        <!--suppress HttpUrlsUsage -->
        <a href="http://example.com/page3">Page-3</a>
        <a href="https://example.com/page4">Page-4</a>
        <a href="https://example.com/page5">Page-5</a>
        <a href="https://example.com/page6">Page-6</a>
        <a href="https://example.com/page7">Page-7</a>
        <a href="https://example.com/page8">Page-8</a>
        <a href="https://example.com/page9">Page-9</a>
        <br><br>

        <h3>CSS [attribute|="value"] Selector</h3>
        <p lang="en">We say: Hello, in English</p>
        <p lang="en-US">We say: Howdy, in the English United States</p>
        <p lang="fr">We say: Bonjour, in French</p>
        <p lang="fr en">We say: Bonjour, in French</p>
        <br><br>

        <h3>CSS [attribute~="value"] Selector</h3>
        <div class="card featured">I am a featured div</div>
        <div class="card highlight">I am a highlight div</div>
        <br><br>

        <h3>Additional Examples</h3>
        <div class="additional-examples">
          <p title="css bg-red1">Please paint my background red</p>
          <p title="css bg-red2">Please paint my background red</p>
          <p title="css bg-red3">Please paint my background red</p>
          <p title="css bg-red3">Please paint my background green</p>
          <br><br>

          <p title="css bg-blue1">Please paint my background blue</p>
          <p title="css bg-blue2">Please paint my background blue</p>
          <p title="css bg-blue3">Please paint my background blue</p>
          <p title="css g-blue3">Please paint my background green</p>
          <br><br>

          <p title="css background">You can set backgrounds of various HTML elements.</p>
          <p title="css background red">You can set backgrounds of various HTML elements.</p>
          <p title="css background green">You can set backgrounds of various HTML elements.</p>
        </div>
        <br><br>

        <h3>Multiple Attribute Selectors</h3>
        <ul class="multiple-attr-selectors">
          <li>
            <!--suppress HtmlUnknownTarget -->
            <a href="web-basics.html">Link 01</a>
          </li>
          <li>
            <!--suppress HtmlUnknownTarget -->
            <a href="web-basics.htm">Link 02</a>
          </li>
          <li>
            <!--suppress HtmlUnknownTarget -->
            <a href="web-basics.com">Link 03</a>
          </li>
          <li>
            <!--suppress HtmlUnknownTarget -->
            <a href="web-basics.co.ke">Link 04</a>
          </li>
        </ul>
      </article><br><br>

      <!--
      CSS Group Selector.
      CSS group selector allows us to apply the same style to multiple elements at a time.
      Names of elements are comma-separated. The group selector keeps CSS concise and avoids redundancy.
      The syntax for the group selector is as follows:
        .class-name1,
        .class-name2,
        .class-name3 {
          property1: value1;
        }
      -->
  		<article class="group-selectors">
        <h2>Group Selectors</h2>
        <p>Example paragraph to be styled by a Group Selector</p>
        <div id="gs">Example div to be styled by a Group Selector</div>
        <span class="gs">Example span to be styled by a Group Selector</span>
      </article><br><br>

      <!--
      CSS Pseudo-Class Selector.
      Pseudo-classes in CSS are used to select and style elements based on their state or position within the document
      tree, without the need to add extra classes or JavaScript.

      What is Pseudo-class?
      Pseudo-classes are often used along with CSS Selectors by inserting a colon (:) after selector.
        For example, a:hover{}, Here selector `a` will select all the anchor tags in a document.

      A functional pseudo-class contains a pair of parentheses to define the arguments.
        For example: :lang(en).

      The element to which a pseudo-class is attached is termed as an anchor element.
        For example, button:hover, a:focus, etc... Here a button and an element are called the anchor elements.

      Pseudo-classes apply style to an element as per the content of the document tree.
      Pseudo-classes also apply a style to an element in relation to the external factors, such as
        - History of the navigation of the element (:visited),
        - Status of the content (:checked), or position of mouse (:hover)

      The syntax for pseudo-class selector is as follows:
        selector:pseudo-class {
          property: value;
        }

      The table given below lists all the CSS pseudo-classes:
      :active................ Represents an element that has been activated by the user.
      :any-link.............. Represents an element that acts as the source anchor of a hyperlink,
                              independent of whether it has been visited.
      :autofill.............. Matches an element that has its value autofill by the browser.
      :checked............... Matches any radio, checkbox or option element that is checked or toggled.
      :default............... Selects form elements that are the default in a group of related elements.
      :defined............... Represents any custom element that has been defined.
      :disabled.............. Represents a disabled element.
      :empty................. Matches an element that has no children.
      :enabled............... Represents an enabled element after it has been activated.
      :first................. Represents the first page of a printed document, with the @page at-rule.
      :first-child........... Represents the first element among a group of sibling elements.
      :first-of-type......... Represents the first element of its type among a group of sibling elements.
      :fullscreen............ Matches an element currently displayed in fullscreen mode.
      :focus................. Represents an element that has received focus.
      :focus-visible......... Applies while an element matches the :focus pseudo-class or receives focus.
      :focus-within.......... Matches an element if the element or any of its descendants are focused.
      :has()................. This represents an element if any of the relative selectors.
      :host.................. This selects the shadow host of the shadow DOM containing the CSS it is used inside.
      :host()................ Selects the shadow host of the shadow DOM containing the CSS it is used inside.
      :host-context()........ Allows styling a custom element based on the classes or attributes of its ancestor elements.
      :hover................. Matches when the user interacts with an element with a pointing device,
                              like a mouse, but does not necessarily activate it.
      :indeterminate......... Represents any form element whose state is indeterminate or unknown.
      :in-range.............. Represents an element whose current value is within the range limits.
      :invalid............... Represents any element whose contents fail to validate.
      :is().................. Takes a selector list as its argument
                              and selects any element that can be selected by one of the selectors in that list.
      :lang()................ Matches an element based on the language they are defined to be in.
      :last-child............ Represents the last element among a group of sibling elements.
      :last-of-type.......... Represents the last element of its type among a group of sibling elements.
      :left.................. Represents all left-hand pages of a printed document, used with @page at-rule.
      :link.................. Represents an element that has not yet been visited.
      :modal................. Matches an element that is in a state in which it excludes all interaction with elements
                              outside it until the interaction has been dismissed.
      :not()................. Represents an element that does not match a list of selectors.
      :nth-child()........... Selects child elements
                              according to their position among all the sibling elements within a parent element.
      :nth-last-child()...... Matches elements based on their position among siblings, counting from the last (end)
      :nth-last-of-type().... Matches elements based on their position among siblings of the same type,
                              counting from the last (end).
      :nth-of-type()......... Matches elements based on their position among siblings of the same type.
      :only-child............ Represents an element without any siblings.
      :only-of-type.......... Represents an element that has no siblings of same type.
      :optional.............. Represents an element that does not have a required attribute set on it.
      :out-of-range.......... Represents an element whose current value is outside the range limits.
      :picture-in-picture.... Matches an element currently in picture-in-picture mode.
      :placeholder-shown..... Represents any element currently displaying placeholder text.
      :read-only............. Represents an element that is not editable by the user.
      :read-write............ Represents an element that is editable by the user.
      :required.............. Represents an element that has a required attribute set on it.
      :right................. Represents all right-hand pages of a printed document, used with @page at-rule.
      :root.................. Matches the root element of a document tree.
      :scope................. Represents elements that are a reference point, or scope, for selectors to match with.
      :target................ Represents the target element with an id matching the URL's fragment.
      :valid................. Represents any element whose contents validate successfully.
      :visited............... Applies once the link has been visited.
      :where()............... Takes a selector list as its argument and selects any element that matches.
      -->
      <article class="pseudo-classes">
        <h2>Pseudo Classes</h2>
        <p class="pseudo-hover">Example paragraph to be styled by a Pseudo HOVER Class</p>
        <p class="pseudo-active">Example paragraph to be styled by a Pseudo ACTIVE Class</p>
        <br>

        <!--
        Pseudo-Class :active.
        Applies style to an element when a user activates the element by clicking or tapping on it.
        This is most commonly used with interactive elements like button and anchor tag, but all the HTML elements can
        use this pseudo-class. The syntax for pseudo-class active selector is as follows:
          tag:active {
            property: value;
          }

        IMPORTANT!
        You must place the :active rule after all the other link-related rules that are defined by, LVHA-order.
          i.e. :link → :visited → :hover → :active
        This is important as the styles specified by :active get overridden by the later link-related
        pseudo-classes, such as, :link, :hover or :visited.
        -->
        <div class="pc-active">
          <h3>Pseudo-Class :active</h3>
          <a href="">Click Me!</a><br>
          <p>Click me to see the effect!</p>
          <ul>
            <li>Item 1</li>
            <li>Item 2</li>
            <li>Item 3</li>
          </ul>

          <form action="">
            <label for="names">Name: </label>
            <input id="names">
            <button id="my-button" type="button">Click Me!</button>
          </form>
        </div><br>

        <!--
        Pseudo-Class :any-link
        The :any-link pseudo-class in CSS represents an element that is the source anchor of a hyperlink,
        irrespective of whether it has been visited or unvisited.
        Thus, it matches all the <a> or <area> elements that have the href attribute.
        In short, it also matches all the elements that match :link or :visited.

        NOTE: This is not supported on safari browser.
        -->
        <div class="pc-any-link">
          <h3>Pseudo-Class :any-link</h3>
          <div>
            <a href="https://github.com/wasulabenjamin">click here</a>
          </div>
          <div>
            <a class="with-no-href">with no href</a>
          </div>
          <div>
            <a href="" class="">with empty href</a>
          </div>
        </div><br>

        <!--
        Pseudo-Class :autofill
        The :autofill pseudo-class in CSS is used to style the appearance of the <input> element, whose value gets
        autofilled by the browser, indicating the user that their previous data has been saved and loaded in the form.
        As the user edits the field, the pseudo-class :autofill stops matching.

        Many browsers, in their internal stylesheets, use important! against the -webkit-autofill style declarations,
        which cannot be overridden by the webpages.

        For the best browser support, you should use both, -webkit-autofill and :autofill.
        :autofill pseudo-class is implemented with the vendor prefix: -webkit- in browsers Chrome, Edge, Opera.
        -->
        <div class="pc-autofill">
          <h3>Pseudo-Class :autofill</h3>
          <form action="" autocomplete="on">
            <label for="autofill-first-name">First Name</label>
            <input type="text" id="autofill-first-name" name="autofill-first-name" autocomplete="autofill-first-name">

            <label for="autofill-last-name">Last Name</label>
            <input type="text" id="autofill-last-name" name="autofill-last-name" autocomplete="autofill-last-name">

            <label for="autofill-email">Email</label>
            <input type="email" id="autofill-email" name="autofill-email" autocomplete="autofill-email">

            <label for="autofill-password">Password</label>
            <input type="password" id="autofill-password" name="autofill-password" autocomplete="autofill-password">

            <button type="submit">Submit</button>
          </form>
        </div><br>

        <!--
        Pseudo-Class :default
        The CSS pseudo-class selector :default selects the form elements that are the default values in the group of
        similar or related elements. This pseudo-class may match the <button>, <input type="checkbox">,
        <input type="radio"> and <option> elements, in the following manner:
          - In the case of a <button>, if it is a <form> submit button.
            It also applies to <input> types that submit forms.
          - In case the checked attribute is specified for <input type="checkbox"> and <input type="radio">.
          - The first option element with the selected attribute.
            In the case of multiple <select>s, having more than one selected option, all will match :default.
        -->
        <div class="pc-default">
          <h3>Pseudo-Class :default and :checked</h3>
          <form action="">
            <fieldset>
              <legend>Choose option</legend>

              <input type="radio" name="option" id="only-a" value="onlyA">
              <label for="only-a">Only A</label>

              <input type="radio" name="option" id="only-b" value="onlyB">
              <label for="only-b">Only B</label>

              <input type="radio" name="option" id="both-AB" value="bothAB" checked>
              <label for="both-AB">Both A & B</label>

              <input type="radio" name="option" id="none" value="none">
              <label for="none">None</label>
            </fieldset>
            <fieldset>
              <legend>Chose Flavor</legend>

              <input type="checkbox" name="flavor" id="butterscotch" value="butterscotch" checked>
              <label for="butterscotch">Butterscotch</label>

              <input type="checkbox" name="flavor" id="chocolate" value="chocolate">
              <label for="chocolate">Chocolate</label>

              <input type="checkbox" name="flavor" id="cookie-cream" value="cookie-cream">
              <label for="cookie-cream">Cookie n Cream</label>

              <input type="checkbox" name="flavor" id="hazelnut" value="hazelnut" checked>
              <label for="hazelnut">Hazelnut</label>

              <input type="checkbox" name="flavor" id="almond" value="almond">
              <label for="almond">Roasted Almond</label>

              <input type="checkbox" name="flavor" id="strawberry" value="strawberry">
              <label for="strawberry">Strawberry</label>
            </fieldset>
          </form>
        </div><br>

        <!--
        Pseudo-Class :defined
        The CSS pseudo-class selector :defined represents an element that has been defined, using the
        customElementRegistry.define() method. This includes standard elements, as well as the custom elements.
        -->
        <div class="pc-defined">
          <h3>Pseudo-Class :defined</h3>
          <!--suppress HtmlUnknownTag -->
          <sample-custom-element
            text="Custom element with font color blue and other styles as per the :defined pseudo-class">
          </sample-custom-element>

          <p>Standard p element with a yellow background, and font as per the :defined pseudo-class</p>

          <script>
            customElements.define(
              "sample-custom-element",
              class extends HTMLElement {
                constructor() {
                  super();

                  let divElement = document.createElement("div");
                  divElement.textContent = this.getAttribute("text");

                  this.attachShadow({ mode: "open" }).appendChild(divElement);
                }
              }
            );
          </script>
        </div><br>

        <!--
        Pseudo-Class :disabled
        The CSS pseudo-class selector :disabled represents an element that is disabled. An element is in a disabled
        state if it cannot be activated (selected, clicked on, typed into, etc.) or doesn't accept focus.
        This is often used with form elements like <input>, <button>, <select>, <textarea>, etc.
        The syntax for the disabled pseudo-class is as follows:
          tag:disabled {
            property: value;
          }
        -->
        <div class="pc-disabled">
          <h3>Pseudo-Class :disabled</h3>
          <form action="">
            <label for="doctor-name">Doctor Name</label>
            <input type="text" id="doctor-name"><br>

            <label for="hospital-name">Hospital Name</label>
            <input type="text" id="hospital-name"><br>

            <label for="diagnosis">Diagnosis</label>
            <input type="text" id="diagnosis" disabled value="Diagnosis"><br><br>

            <button type="submit" disabled>Submit</button>
            <button type="reset">Reset</button>
          </form>
        </div><br>

        <!--
        Pseudo-Class :empty
        The CSS pseudo-class selector :empty represents an element that is empty and has no children.
        An element can be called empty if:
          - It has nothing between its tags or contains code comment(s) only.
              For example, <div></div>
          - The CSS for the element generates content, such as from a pseudo-element like ::before or ::after.
              For example, div::before {content: "Empty element"}
          - Self-closing elements like <br>, <hr> and <img> are also considered as empty.

          Accessibility concerns:
          Interactive content that is empty cannot be parsed by the assistive technologies, such as screen readers.
          Hence, all interactive content must have an accessible name that can be provided by a text value for the
          interactive control's parent element, which in turn makes it accessible to the assistive technologies.
        -->
        <div class="pc-empty">
          <h3>Pseudo-Class :empty</h3>
          <div class="example-1">
            <p>Not an empty paragraph</p>
            <p></p>
            <p>Not an empty paragraph</p>
          </div>

          <div class="example-2">
            <div class="circle"><!-- Yellow circle --></div>

            <div class="circle"><!-- not an empty element-->
              <h2>:empty</h2>
            </div>

            <div class="circle">
              <p>
                <!-- Non-collapsible whitespace and elements around this comment. -->
              </p>
            </div>
          </div>
        </div><br>

        <!--
        Pseudo-Class :enabled
        The CSS pseudo-class selector :enabled represents an element that is enabled.
        An element is in an enabled state, if it can be activated (selected, clicked on, typed into, etc.).
        ... or accepts focus.
        -->
        <div class="pc-enabled">
          <h3>Pseudo-Class :enabled</h3>
          <form action="">
            <label for="pce-first-name">First Name</label>
            <input type="text" id="pce-first-name"><br>

            <label for="pce-last-name">Last Name</label>
            <input type="text" id="pce-last-name"><br>

            <label for="pce-address">Address</label>
            <input type="text" id="pce-address" disabled value="Address">

            <br><br>
            <input type="reset" disabled>
            <input type="submit">
          </form>
        </div><br>

        <!--
        Pseudo-Class :first
        The CSS pseudo-class selector :first selects the first page of a printed document.
        It is used with the @page at-rule.

        All CSS properties cannot be changed using the :first pseudo-class.
        The properties that can be changed are margins, orphans, widows, and page breaks of the document.
        Also, only absolute-length units can be used for margins while using this pseudo-class.
        All the other properties will be ignored.

        Orphan is a CSS property that sets the minimum number of lines in a block container
        that must be shown at the bottom of a page.
        Widow is a CSS property that sets the minimum number of lines in a block container
        that must be shown at the top of a page.

        Syntax:
          @page:first {
             /* ... */
          }

        The following example demonstrates the use of :first pseudo-class. Here we see:
          - A document is created with three pages, as we have used page-break-after: always on a p element.
          - The first page of the document is styled using the @page at-rule and the :first pseudo-class.
          - The first page will have the top margin = 5in
          - The rest two pages show the text on its default location, 1in from the top.
        -->
        <div class="pc-first">
          <h3>Pseudo-Class :first</h3>

          <h1>Annual Report</h1>
          <p>
            This is the first page.
            Notice that when you print this document, the top and bottom margins are much larger on the first page.
          </p>

          <div class="page-break"></div>

          <h1>Second Page</h1>
          <p>
            This is the second page.
            The margins here are smaller because the :first pseudo-class no longer applies.
          </p>

          <div class="page-break"></div>

          <h1>Third Page</h1>
          <p>And here’s a third page, just to reinforce the difference.</p>

          <button id="print-button">Print Me</button>

          <script>
            document.getElementById("print-button").addEventListener("click", () => {
              const printSection = document.querySelector(".pc-first").innerHTML;
              const printWindow = window.open("", "_blank");

              // noinspection CssUnusedSymbol
              printWindow.document.write(`
                <html lang="en">
                  <head>
                    <title>Print</title>
                    <style>
                      /* Controls global print layout (margins, size, etc.) */
                      @page {
                        margin: 1in;
                      }

                      /* Controls the first page layout (margins, size, etc.) */
                      @page:first {
                        margin-top: 5in;
                      }

                      .page-break {
                        page-break-before: always; /* Forces a page break before this element */
                      }
                    </style>
                  </head>
                  <body>${printSection}</body>
                </html>
              `);
              printWindow.document.close();
              printWindow.focus();
              printWindow.print();
              printWindow.close();
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :first-Child.
        The pseudo-class first-child is used to select the first direct child element.
        The syntax for pseudo-class first-child selector is as follows:
          tag:first-child {
            property: value;
          }
        -->
        <div class="pc-first-child">
          <h3>Pseudo-Class :first-child</h3>

          <section>
            <p>This paragraph is the first child of a section element, will be blue.</p>
            <p>This paragraph will not be affected.</p>
            <p>Another paragraph that won't be affected.</p>
          </section>

          <div>
            <p>This paragraph is the first child of a div element will be blue.</p>
            <p>This paragraph will not be affected.</p>
            <p>Another paragraph that won't be affected.</p>
          </div>

          <div>
            <ul>
              <li>One</li>
              <li>Two</li>
              <li>
                Three
                <ul>
                  <li>Three 1</li>
                  <li>Three 2</li>
                  <li>Three 3</li>
                </ul>
              </li>
            </ul>
          </div>

        </div><br>

        <!--
        Pseudo-Class :first-of-type
        Used to select and style the first element of its type within its parent container. This pseudo-class lets you
        target and apply the styles specifically to the first occurrence of an element within a given container.

        The CSS pseudo-class selector :first-child is similar to :first-of-type, but there is a difference: it is less
        specific.
        - The :first-child matches only the first child of a parent element; whereas
        - The :first-of-type matches the specified elements child even if it is not the first one.
        -->
        <div class="pc-first-of-type">
          <h3>Pseudo-Class :first-of-type</h3>
          <div>
            <h4>Parent element</h4>
            <p>The first child looks different due to :first-of-type pseudo-class</p>
            <p>second child, so no change</p>
          </div>
          <div>
            <h4>Parent element</h4>
            <h4>h4 tag, so no change</h4>
            <p><b>p</b> tag, and first-of-type of paragraph under this parent.</p>
          </div>

          <div>
            <ul>
              <li>One</li>
              <li>Two</li>
              <li>
                Three
                <ul>
                  <li>Three 1</li>
                  <li>Three 2</li>
                  <li>Three 3</li>
                </ul>
              </li>
            </ul>
          </div>
        </div><br>

        <!--
        Pseudo-Class :focus.
        Applies style to an element when the user focuses on an element like input tag by clicking on it.
        Before typing text in the input element, a user has to click in the input area to enable the cursor;
        this is called focusing. The syntax for pseudo-class focus selector is as follows:
          tag:focus {
            property: value;
          }
        -->
        <div class="pc-focus">
          <h3>Pseudo-Class :focus</h3>

          <label for="something">Type Something:</label>
          <input type="text" id="something" name="something" placeholder="Type something mate!">

          <p>The link here has a <a href="#">change in background and foreground color</a> as it is focused.</p>

          <button>Click Me!!</button>

          <form>
            <label for="flavors">Ice Cream Flavors:</label>
            <select name="flavor" id="flavors">
              <option>Cookie dough</option>
              <option>Pistachio</option>
              <option>Cookies & Cream</option>
              <option>Cotton Candy</option>
              <option>Lemon & Raspberry Sorbet</option>
            </select>
          </form>

          <div class="toggle">
            <label for="toggle1">Check the box to toggle me</label>
            <input type="checkbox" id="toggle1">
            <span></span>
          </div>
        </div><br>

        <!--
        Pseudo-Class :focus-visible
        The :focus-visible pseudo-class in CSS represents an element that has received focus.
        This class is generally triggered when a user clicks, taps on an element or selects an element using the tab key
        of a keyboard. The :focus-visible pseudo-class can be used to apply a different focus indicator, as per the
        user's preferred mode of functioning (either using a mouse or a keyboard).

        :focus vs. :focus-visible
        The :focus and :focus-visible pseudo-classes in CSS are used to target elements that currently have keyboard
        focus, but they behave differently, especially with regard to user experience and accessibility.

        :focus
        Targets elements that have keyboard focus, whether that focus is achieved through keyboard navigation or by
        clicking with the mouse.
        It doesn't take into account how the user reached the focused element, so it can include cases where a user
        clicked on an element with a mouse or tapped it on a touch device.

        :focus-visible
        Targets elements that have keyboard focus but are only visible when keyboard navigation is used.
        This helps improve user experience by ensuring that styles are applied only when an element is focused via
        keyboard input and not when focused via mouse or touch input.
        It is especially useful for creating a more accessible and user-friendly experience for keyboard users,
        as it avoids applying potentially distracting or irrelevant styles to elements when clicked with a mouse.
        -->
        <div class="pc-focus-visible">
          <h3>Pseudo-Class :focus-visible</h3>
          <button class="btn-f">focus-only</button>
          <button class="btn-fo">focus-visible</button>
        </div><br>

        <!--
        Pseudo-Class :focus-within
        Selects an element if it contains an element that has received focus (:focus).
        For example, if you want to highlight or focus a complete form, when focus is set on any of the input fields,
        use the pseudo-class :focus-within.
        -->
        <div class="pc-focus-within">
          <h3>Pseudo-Class :focus-within</h3>
          <label for="fw-first-name">
            First Name
            <input type="text" id="fw-first-name">
          </label>

          <form>
            <label>
              Ice cream Flavors:
              <select name="flavor">
                <option>Cookie dough</option>
                <option>Pistachio</option>
                <option>Cookies & Cream</option>
                <option>Cotton Candy</option>
                <option>Lemon & Raspberry Sorbet</option>
              </select>
            </label>
          </form>
        </div><br>

        <!--
        Pseudo-Class :fullscreen
        The CSS pseudo-class selector :fullscreen targets and styles an element being displayed in fullscreen mode.
        If more than one element is set in fullscreen mode, this pseudo-class selects all of them.
        Typically, this pseudo-class is used with ::backdrop pseudo-elements to style backdrop behind a fullscreen
        element.

        The pseudo-class :fullscreen lets one configure the stylesheets to automatically adjust the layout,
        style or size of the content when the elements are toggled back and forth between fullscreen and normal modes.

        Select all elements in the fullscreen stack is supported only in the Firefox browser.
        -->
        <div class="pc-fullscreen">
          <h3>Pseudo-Class :fullscreen</h3>
          <p>Fullscreen mode</p>
          <br>
          <button id="fullscreen-toggle">Click here</button>
          <script>
            document.getElementById("fullscreen-toggle").addEventListener("click", () => {
              const element = document.querySelector(".pc-fullscreen");
              element.requestFullscreen();
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :has() and :is()

        ----------------------------------------------------------------------------------------------------------------

        Pseudo-Class :has()
        This pseudo-class represents an element based on whether it has a child element that matches a certain selector.

        Syntax,
          :has(<relative-selector-list>) {
             /* ... */
          }

        The :has() pseudo-class is not supported by the Firefox browser.

        POINTS TO REMEMBER. 💡
        - When a browser doesn't support the :has() pseudo-class,
          the entire selector block will only work if :has() is used inside an :is() or :where() selector.
        - You can't use a :has() selector inside another :has()selector because many pseudo-elements exist based on how
          their parent elements are styled. Allowing you to select these pseudo-elements with :has() can cause cyclic
          querying.
        - Pseudo-elements cannot be used as selectors or anchors within the :has() pseudo-class.

        ----------------------------------------------------------------------------------------------------------------

        Pseudo-Class :is()
        The CSS pseudo-class function :is() takes the arguments as a list of selectors and thus targets any element
        that can be selected by any of the selectors in the list.

        - It simplifies a large number of selectors that are required to be written, in a more compact form.
        - Simplifies the section selectors i.e., while dealing with HTML sections and headings at different levels,
          such as <section>, <article>, <aside>, and <nav>.
        - Does not select pseudo-elements.

        :is() vs :where()
        :is() is responsible for counting towards a more specific of all the selectors in the list,
        whereas :where() holds the specificity value of 0.

        Forgiving selector parsing
        - With usage of :is() and :where(), when one of the selectors fails to parse,
          instead of the whole list of selectors being deemed invalid,
          only the incorrect or unsupported selectors gets ignored and the rest of the selectors are used.
        - :is(:valid, :unsupported) − this will parse correctly and match :valid,
          even when the browsers don't support :unsupported.

        ----------------------------------------------------------------------------------------------------------------

        The CSS pseudo-class selector :has() and :is() are used to select elements that have a descendant element
        that matches the specified selector.
        The syntax for :has() and :is() pseudo-class selectors is as follows:
          tag:has(selector) {
            property: value;
          }
          tag:is(selector) {
            property: value;
          }

        POINTS TO REMEMBER. 💡
          1. `:has()` is a relational pseudo-class, it selects elements based on its descendants, children, or siblings.
              For Example:
                div:has(> img) { border: 2px solid green; } /* has direct child */
                article:has(h2 + p) { background: yellow; } /* has sibling relationship inside */
          2. `:is()` is a selector simplifier, it matches any of a list of selectors.
              For Example:
                :is(h1, h2, h3) { font-weight: bold; }
          3. `:has()` and `:is()` are compatible, they can be used together:
              For Example:
                section:has(:is(h2, h3)) { border-color: red; }
          4. They can be combined with `:not()` and `:where()` without issue.
              For Example:
                div:not(:has(img)) { opacity: 0.5; }
          5. Limitations:
              * `:has()` cannot contain pseudo-elements (`::before`, `::after`, etc.)
              * `:has()` cannot nest inside another `:has()`

        Regular Expressions and :has() Analogy
        CSS :has() selectors and regular expressions with lookahead assertions share a similarity in that they enable
        you to target elements (or strings) based on a specific pattern, all without actually choosing the element
        (or string) that matches that pattern.
          * Positive lookahead (?=pattern)
            CSS selector and the regular expression abc(?=xyz) both allow you to select an element based on the presence
            of another element immediately after it, without actually selecting the other element itself.
          * Negative lookahead (?!pattern)
            CSS selector .abc:has(+ :not(.xyz)) is like the regular expression abc(?!xyz).
            Both select .abc only if it is not followed by .xyz.
        -->
        <div class="pc-has">
          <h3>Pseudo-Class :has() and :is()</h3>
          <h4>Parent H4 element</h4>
          <p>The first child looks different due to :has() pseudo-class</p>
          <p>second child, so no change</p>

          <div>
            <h4>Heading 1 Example</h4>
            <a href="">Link A Example</a>.
            <p>Paragraph 1</p>

            <h4>Heading 1 Example</h4>
            <p>Paragraph 1 Example</p>
            <p>Paragraph 2 Example</p>

            <h4>Heading 2 Example</h4>
            <p>Paragraph 1 Example</p>
            <p>Paragraph 2 Example <a href="">Link B</a></p>
          </div>

          <div>
            <video src="../../assets/video/sample-video.mp4" controls></video>
            <audio src="../../assets/audio/sample-audio.mp3" controls></audio>
          </div>
        </div><br>

        <!--
        Pseudo-Class :host
        The CSS pseudo-class selector :host is mainly useful in styling the host element or the container of a web
        component, from within the component's shadow DOM. A web component is a custom element that is defined and built
        using HTML, JavaScript or CSS. These components are reusable.

        When the pseudo-class :host is used to style, it targets the element that hosts the web component,
        unlike targeting the elements within the shadow DOM itself. This is helpful in encapsulation of styles within a
        web component and prevents their leakage to other elements or getting affected by the external styling.

        The :host pseudo-class has no effect when used outside a shadow DOM.
        -->
        <div class="pc-host">
          <h3>Pseudo-Class :host</h3>

          <h4>See the list:</h4>
          <ul>
            <li>
              <!--suppress HtmlUnknownTag -->
              <sample-span>Web component - Custom element</sample-span>
            </li>
            <li>
              <!--suppress HtmlUnknownTag -->
              <sample-span>Host element</sample-span>
            </li>
            <li>
              <!--suppress HtmlUnknownTag -->
              <sample-span>HTML, JS, CSS</sample-span>
            </li>
          </ul>
          <script>
            customElements.define("sample-span", class extends HTMLElement {
              constructor() {
                super();

                const shadow = this.attachShadow({mode: "open"}); // Create shadow DOM
                const style = document.createElement("style");    // Create a style element
                const span = document.createElement("span");      // Create span element

                style.textContent = `
                  :host {
                    background-color: yellow;
                    padding: 5px;
                    color: blue;
                    border: 2px solid red;
                  }
                `; // Add style to shadow DOM

                span.textContent = this.textContent; // Add text content to span element
                shadow.append(style, span); // Append style and span to shadow DOM
              }
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :host()
        The :host() CSS pseudo-class function allows you to select a custom element from inside its shadow DOM, \
        but only if the selector (e.g., a class selector) given as the function's parameter matches the shadow host.
        The :host() pseudo-class function has no effect when used outside a shadow DOM.
        -->
        <div class="pc-host-b">
          <h3>Pseudo-Class :host()</h3>
          <p>
            Lorem ipsum dolor sit amet,
            <!--suppress HtmlUnknownTag -->
            <paragraph-span class="pg-span">consectetur radicalising elit.</paragraph-span>
          </p>

          <script>
            customElements.define("paragraph-span", class extends HTMLElement {
              constructor() {
                super();

                const shadow = this.attachShadow({ mode: "open" }); // Create shadow DOM
                const style = document.createElement("style");      // Create a style element
                const span = document.createElement("span");        // Create span element

                style.textContent = `
                  :host(.pg-span) {
                    background-color: yellow;
                    padding: 5px;
                    color: blue;
                    border: 2px solid red;
                  }
                `; // Add style to shadow DOM

                span.textContent = this.textContent; // Add text content to span element
                shadow.append(style, span);          // Append style and span to shadow DOM
              }
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :host-context()
        CSS :host-context() pseudo-class selector allows you to style a custom element differently depending on where it
        is used in the DOM, based on the classes or attributes of its ancestor elements.
        The :host-context() pseudo-class function has no effect when used outside a shadow DOM.

        Syntax,
            :host-context(<compound-selector>) {
              property: value;
            }

        NOTE: The :host-context() is not supported by Firebox and Safari Browser.
        -->
        <div class="pc-host-context">
          <h3>Pseudo-Class :host-context()</h3>

          <h4>CSS Basics -
            <a href="#">
              <!--suppress HtmlUnknownTag -->
              <context-span></context-span>
            </a>
          </h4>
          <aside>
            <!--suppress HtmlUnknownTag -->
            <context-span></context-span> pseudo-class selector allows you to style a custom element differently
            depending on where it is used in the DOM, based on the classes or attributes of its ancestor elements.
          </aside>

          <script>
            customElements.define("context-span", class extends HTMLElement {
              constructor() {
                super();

                const shadowRoot = this.attachShadow({ mode: "open" }); // Create shadow DOM
                const style = document.createElement("style");          // Create a style element

                style.textContent = `
                  :host-context(aside) {
                    background-color: violet;
                    color: blue;
                    border: 3px solid red;

                    &::after {
                      content: "This is an aside element";
                    }
                  }

                  :host-context(:not(aside))::after {
                    content: "This is not an aside element";
                  }
                `; // Add style to shadow DOM

                shadowRoot.appendChild(style); // Append style to shadow DOM
              }
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :hover.
        The `:hover` pseudo-class in CSS applies styles to an element when a user’s mouse pointer is over it.
        It’s commonly used to create interactive effects such as changing colors, revealing elements, etc.
          Syntax,
            selector:hover {
               property: value;
            }
        -->
        <div class="pc-hover">
          <h3>Pseudo-Class :hover</h3>

          <div class="example-1">
            <a href="#">Hover over to see the color change!!!</a>
          </div>

          <div class="example-2">
            <button>Hover me!!!</button>
          </div>

          <div class="example-3">
            <a class="link" href="#">Check my borders on hover</a>
          </div>

          <div class="example-4">
            <a href="#">Hover over me!!</a>
          </div>

          <div class="example-5">
            <a href="#">Hover over me!!</a>
          </div>

          <div class="example-6">
            <a href="#">Hover over me!!</a>
          </div>

          <div class="example-7">
            <button class="glow" type="button">HOVER OVER & CLICK!</button>
          </div>
        </div><br>

        <!--
        Pseudo-Class :indeterminate
        The CSS pseudo-class selector :indeterminate represents an element whose state is indeterminate or unknown.
        To be more specific, the :indeterminate pseudo-class targets the following elements:
          * Checkbox - <input type="checkbox"> whose indeterminate value is set to true.
          * Radio button - <input type="radio"> whose radio button group does not list any checked radio button.
          * Progress element - <progress> in an indeterminate state, i.e., with no value attribute.
        -->
        <div class="pc-indeterminate">
          <h3>Pseudo-Class :indeterminate</h3>
          <input type="checkbox" id="check-box">
          <label for="check-box">Checkbox</label>

          <input type="radio" id="radio">
          <label for="radio">Radio</label>

          <progress></progress>

          <script>
            document.getElementById("check-box").indeterminate = true;
            document.getElementById("radio").indeterminate = true;
          </script>
        </div><br>

        <!--
        Pseudo-Class :in-range
        The CSS pseudo-class selector :in-range represents an <input>element whose value is within the range limited by
        the min and max attributes. This gives a visual indication to the user about the current value of a field,
        whether it is within the permitted range of values or not.
        This can only apply to the elements that can either have or take values in a range limitation.
        When there is no such limitation, the element is said to be neither in-range nor out-of-range.

        The syntax for pseudo-class :in-range is as follows:
          tag:in-range {
            property: value;
          }

        The CSS pseudo-class selector :out-of-range represents an <input>element whose value is outside the range
        limited by the min and max attributes. This gives a visual indication to the user about the current value of a
        field, that it is outside the permitted range of values.
        This can only apply to the elements that can either have or take values in a range limitation.
        When there is no such limitation, the element is said to be neither in-range nor out-of-range.

        The syntax for pseudo-class :out-of-range is as follows:
          tag:out-of-range {
            property: value;
          }
        -->
        <div class="pc-in-range">
          <h3>Pseudo-Class :in-range</h3>
          <label for="in-range">Pick a number between 1 and 50: </label>
          <input type="number" min="1" max="50" value="1" id="in-range">
          <label></label>
        </div><br>

        <!--
        Pseudo-Class :invalid
        The CSS pseudo-class selector :invalid represents an element (such as <form>, <fieldset>, or <input>) whose
        contents or value is invalid as per its type specified in the type attribute, or fail to validate.
        For instance, email inputs, <input type="email"> whose value does not match a valid email pattern or a number
        input <input type="number"> having a value with alphabets. Both these cases are invalid.

        The pseudo-class :invalid is useful in indicating the field errors to the user.
        - Any style applied using :out-of-range pseudo-class, overrides the styles applied using :invalid pseudo-class.
          Works for <input type="number">.
        - The :invalid pseudo-class can be used with other selectors, such as hover, :focus, etc.
        - In the case of radio buttons, if one of them is required,
          the :invalid pseudo-class is applied to all the radio buttons.
        - Gecko does not apply a style to the :invalid pseudo-class.
          However, Gecko does apply a style to :user-invalid pseudo-class.

        Accessibility concerns:
        For an invalid input, the default color used is red, which might be challenging for people with certain color
        blindness state. Instead, it is advisable to add an icon or descriptive text along with the invalid input so
        that it is easier to understand.
        -->
        <div class="pc-invalid">
          <h3>Pseudo-Class :invalid</h3>

          <p>Input type is a number ranging between 1 and 10.</p>
          <input type="number" id="number-input" min="1" max="10" value="2">
          <label for="number-input"></label>

          <p>The input type is email, which is required. If empty, it's invalid.</p>
          <input type="email" id="email-input" placeholder="abc@gmail.com" required>
          <label for="email-input"></label>

          <form>
            <fieldset>
              <label for="user-id">UserId</label><br>
              <input type="number" name="user-id" id="user-id" required>
              <label for="user-id"></label>
            </fieldset>

            <fieldset>
              <label for="user-email">Email</label><br>
              <input type="email" name="user-email" id="user-email" required>
              <label for="user-email"></label>
            </fieldset>

            <button type="submit" name="send">Submit</button>
          </form>
        </div><br>

        <!--
        Pseudo-Class :lang()
        Applies style to an element based on the value of lang attribute set to the element, or it's parent.
        This pseudo-class matches the elements as per the language that is passed in the function as an argument.

        Possible Values, <language-code>
        - A list of one or more <string>s separated by commas that target an element with language values.
        - The value should be according to BCP47 language codes.
        - The matching language range is case-sensitive.

        Implicit wildcard matching is allowed,
        such that :lang(de-DE) will match de-DE, de-DE-1996, de-Latn-DE, de-Latf-DE and de-Latn-DE-1996.

        Using wildcards explicitly will require including a full match of language subtag.
        -->
        <div class="pc-lang">
          <h3>Pseudo-Class :lang()</h3>
          <q lang="en">This language is set as English, Here css use double(" ") quotes</q><br>
          <q lang="fr">This language is set as French, Here css use guillemet( ) quotes</q>
        </div><br>

        <!--
        Pseudo-Class :last-child
        The pseudo-class last-child used to select the last direct child element.
        The CSS pseudo-class selector :last-child represents the last element that is inside the containing element.

        The pseudo-class :last-child is similar to :last-of-type, but the former is more specific and targets the very
        last child of the parent element, while the latter matches the last occurrence of a specified element.

        The syntax for pseudo-class last-child selector is as follows:
          tag:last-child {
            property: value;
          }
        -->
        <div class="pc-last-child">
          <h3>Pseudo-Class :last-child</h3>
          <section>
            <p>This paragraph is the first child of a section element</p>
            <p>This paragraph will not be affected.</p>
            <p>This is the last paragraph that will not be affected.</p>
            <span>This is the last child of a span element</span>
          </section>

          <div>
            <p>This paragraph is the first child of a div element</p>
            <p>This paragraph will not be affected.</p>
            <p>This is the last paragraph that will be affected.</p>
          </div>

          <ul>
            <li>One</li>
            <li>Two</li>
            <li>Three
          </ul>
        </div><br>

        <!--
        Pseudo-Class :last-of-type
        The CSS pseudo-class selector :last-of-type is used to select and style the last element of its type within its
        parent container. This pseudo-class lets you target and apply the styles specifically to the last occurrence of
        a kind of element within a given container.

        :last-child vs. :last-of-type
        The CSS pseudo-class selector :last-child is similar to :last-of-type, but there is a difference: it is less
        specific. The :last-child matches only the last child of a parent element; whereas :last-of-type matches the
        specified elements child even if it is not the last one.
        -->
        <div class="pc-last-of-type">
          <h3>Pseudo-Class :last-of-type</h3>

          <div class="example-1">
            <section>
              <p>This paragraph is the first child of a section element</p>
              <p>This paragraph will not be affected.</p>
              <p>This is the last paragraph that will be affected.</p>
              <span>This is the last child of a span element</span>
            </section>

            <div>
              <p>This paragraph is the first child of a div element</p>
              <p>This paragraph will not be affected.</p>
              <p>This is the last paragraph that will be affected.</p>
            </div>
          </div>

          <div class="example-2">
            <div class="item">first div, so no change.</div>
            <div class="item">second div, so no change.</div>
            <div class="item">Third div, last child of the parent div, so CSS applied.</div>
            <p class="item">Last p element of its parent, selected by .container.item class selector.</p>
          </div>
        </div><br>

        <!--
        Pseudo-Class :left
        The CSS pseudo-class selector :left represents all left-hand pages of a printed document.
        It is used with the @page at-rule.

        Based on the writing direction of the document, it is determined whether it is "left" or "right".
        In case the writing direction is left-to-right, the document is said to be :right and
        when the major writing direction is right-to-left, it is :left page.

        All CSS properties cannot be changed using the :left pseudo-class.
        The properties that can be changed are margin, padding, border, and background.
        Just the page box will be affected and not the content on the page.
        -->
        <div class="pc-left">
          <h3>Pseudo-Class :left</h3>

          <section>
            <h1>Page 1</h1>
          </section>
          <section>
            <h1>Page 2</h1>
          </section>

          <button id="print-pc-link">Print</button>

          <script>
            document.getElementById("print-pc-link").addEventListener("click", () => {
              const printSection = document.querySelector(".pc-link").innerHTML;
              const printWindow = window.open("", "_blank");

              // noinspection CssUnusedSymbol
              printWindow.document.write(`
                <html lang="en">
                  <head>
                    <title>Print</title>
                    <style>
                      @page:left {
                        margin: 2in 3in;
                      }

                      body {
                        display: grid;
                      }

                      section {
                        border-radius: 10px;
                        display: grid;
                        margin: 2px;
                        padding: 0.25rem;
                        place-items: center;
                        width: 35%;
                        print-color-adjust: exact;
                        -webkit-print-color-adjust: exact;
                      }

                      section {
                        page-break-after: always;
                        break-after: page;
                      }

                      button {
                        visibility: hidden;
                        padding: 10px;
                        width: 20%;
                        height: 50px;
                        margin-left: 55px;
                        margin-top: 10px;
                      }
                    </style>
                  </head>
                  <body>${printSection}</body>
                </html>
              `);
              printWindow.document.close();
              printWindow.focus();
              printWindow.print();
              printWindow.close();
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :link
        -->
        <div class="pc-link">
          <h3>Pseudo-Class :link</h3>
          <strong><a href="#">TutorialsPoint</a></strong>
          <strong><a href="#">Google</a></strong>
        </div><br>

        <!--
        Pseudo-Class :modal
        -->
        <div class="pc-modal">
          <h3>Pseudo-Class :modal</h3>

          <dialog>
            <button autofocus>close</button>
            <p>The modal dialog has a beautiful backdrop!</p>
            <p>And see my styling using :modal pseudo-class</p>
          </dialog>
          <button>Open the Dialog</button>

          <script>
            const dialog = document.querySelector("dialog");
            const buttonOpen = document.querySelector("dialog + button");
            const buttonClose = document.querySelector("dialog button");

            buttonOpen.addEventListener("click", () => dialog.showModal());
            buttonClose.addEventListener("click", () => dialog.close());
          </script>
        </div><br>

        <!--
        Pseudo-Class :not()
        The pseudo-class :not(selector) is used to apply style on all the elements expect elements that included in
        mentioned selectors.
        The syntax for pseudo-class not selector is as follows:
          tag:not(selector){
            property: value;
          }
        The selector can be a class, id, or tag in HTML.
        -->
        <div class="pc-not">
          <h3>Pseudo-Class :not()</h3>
          <p>This is a normal paragraph.</p>
          <p class="special" id="super-special">This is a super special paragraph.</p>
          <p>This is another normal paragraph.</p>
          <p class="special">This is a special paragraph.</p>
        </div><br>

        <!--
        Pseudo-Class :nth-child()
        The pseudo-class :nth-child(n) will apply style to any specified direct child of an element.
        The syntax for pseudo-class nth-child(n) selector is as follows:
          tag:nth-child(number/ expression / odd / even) {
            property: value;
          }

        The pseudo-class nth-child can take number, mathematical expression or values like odd, even as parameter.
        * Think of `n` as a free variable that takes all whole numbers starting at 0 and increasing by 1.
        * The formula (`an+b`) is evaluated for every `n`.
        * If the result is a valid child index (≥1 and ≤ number of children), then that child matches.
        * If the result is ≤0 or > the number of children, it just produces no match (not an error, just ignored).

        So it’s not recursion (nothing calls itself again) — it’s more like generating a sequence of numbers (1, 23, …),
        plugging each into the formula, and checking whether the result is a valid child index.

        * `:nth-child()` starts counting from the first child forward.
        * `:nth-last-child()` starts counting from the last child backward (same formula logic, applied from the back).

        REMEMBER! 👉
        The “engine” never stops generating results (in theory, it’s infinite),
        but in practice you “run out” when indices go outside the child range.
        See the below example for a 10-item list:

        for -n+1;
        n = -0 + 1 →  1 ✅
        n = -1 + 1 →  0 ❌
        n = -2 + 1 → -1 ❌
        n = -3 + 1 → -2 ❌ ... don't continue as we will always get a negative

        for n+1;
        n = 0 + 1 →  1 ✅
        n = 1 + 1 →  2 ✅
        n = 2 + 1 →  3 ✅
        n = 3 + 1 →  4 ✅ ... continue until we run out of children

        for 3n+4;
        n = 3 * 0 + 4 → 4  ✅
        n = 3 * 1 + 4 → 7  ✅
        n = 3 * 2 + 4 → 10 ✅ ... don't continue since we only have 10 list items

        for 5n;
        n = 5 * 0 → 0   ❌ (0 is invalid, there’s no “0th child”).
        n = 5 * 1 → 5   ✅
        n = 5 * 2 → 10  ✅ ... again, don't continue since we only have 10 list items
        -->
        <div class="pc-nth-child">
          <h3>Pseudo-Class :nth-child()</h3>
          <p>Second child of div</p>
          <div>
            <div>Div 1</div>
            <div>Div 2</div>
            <div>Div 3</div>
            <div>Div 4</div>
            <div>Div 5</div>
            <div>Div 6</div>
          </div>
        </div><br>

        <!--
        Pseudo-Class :nth-last-child()
        -->
        <div class="pc-nth-last-child">
          <h3>Pseudo-Class :nth-last-child()</h3>

          <p>Styling the last item as bold and red color.</p>
          <p>Styling every third list item starting with the fourth list item from the last with a pink background.</p>
          <p>Styling the fifth item from last as bold.</p>
          <ol>
            <li>Item 1</li>
            <li>Item 2</li>
            <li>Item 3</li>
            <li>Item 4</li>
            <li>Item 5</li>
            <li>Item 6</li>
            <li>Item 7</li>
            <li>Item 8</li>
            <li>Item 9</li>
            <li>Item 10</li>
          </ol>

          <ul class="results">
            <li>Alice — 98%</li>
            <li>Bob — 95%</li>
            <li>Carol — 92%</li>
            <li>David — 80%</li>
            <li>Eve — 75%</li>
            <li>Frank — 70%</li>
            <li>Grace — 65%</li>
            <li>Heidi — 60%</li>
            <li>Ivan — 55%</li>
            <li>Judy — 50%</li>
          </ul>

          <p>Styling the heading of the table as bold and blue in color.</p>
          <p>Styling all odd-numbered rows from the end with a pink background color.</p>
          <p>Styling all even-numbered rows from the end with a greenyellow background color.</p>
          <table>
            <tr> <th>Names        </th> </tr>
            <tr> <td>John Sean    </td> </tr>
            <tr> <td>Rocky Luis   </td> </tr>
            <tr> <td>Oliver David </td> </tr>
            <tr> <td>Marry Allan </td> </tr>
            <tr> <td>Dora Ann     </td> </tr>
          </table>

          <h3>Styling list items with the class fruits to have a pink background.</h3>
          <h3>Counting from the last child, styling a first child element of the fruit class.</h3>
          <ul>
            <li>Orange</li>
            <li>Apple</li>
            <li class="fruits">Mango</li>
            <li>Grapes</li>
            <li class="fruits">Banana</li>
            <li>Watermelon</li>
            <li class="fruits">Cheery</li>
            <li class="fruits">Pear</li>
          </ul>
        </div><br>

        <!--
        Pseudo-Class :last-of-type()
        -->
        <div class="pc-nth-last-of-type">
          <h3>Pseudo-Class :nth-last-of-type()</h3>
          <p>Lorem Ipsum is simply fake text of the printing and typesetting industry. </p>
          <p>Lorem Ipsum is simply fake text of the printing and typesetting industry. </p>
          <p>Contrary to popular belief, Lorem Ipsum is not simply a random text.</p>
          <p>The standard chunk of Lorem Ipsum used since the 1500s</p>
          <p>Sections 1.10.32 and 1.10.33 from "de Minibus Bono rum et Malo rum" by Cicero</p>
          <p>Lorem Ipsum is therefore always free from repetition.</p>
        </div><br>

        <!--
        Pseudo-Class :nth-of-type()
        -->
        <div class="pc-nth-of-type">
          <h3>Pseudo-Class :nth-of-type()</h3>
          <p>This is the first <b>p</b> tag. </p>
          <div>This is first <b>div</b> tag.</div>
          <p>This is the second <b>p</b> tag.</p>
          <p>This is the third <b>p</b> tag.</p>
          <p>This is the fourth <b>p</b> tag.</p>
          <div>This is second <b>div</b> tag..</div>
        </div><br>

        <!--
        Pseudo-Class :only-child
        -->
        <div class="pc-only-child">
          <h3>Pseudo-Class :only-child</h3>

          <div class="field">
            <p>Ordered list:</p>
            <ol>
              <li>Only one item</li>
            </ol>
          </div>

          <div class="field">
            <p>Ordered list:</p>
            <ol>
              <li>One item</li>
              <li>Two items</li>
            </ol>
          </div>

          <div class="field">
            <p>Unordered list:</p>
            <ul>
              <li>First Item</li>
            </ul>
          </div>
        </div><br>

        <!--
        Pseudo-Class :only-of-type
        -->
        <div class="pc-only-of-type">
          <h3>Pseudo-Class :only-of-type</h3>

          <div class="field">
            <h2>Heading 2—only type</h2>
            <p>Paragraph tag - only type</p>
          </div>

          <div class="field">
            <h2>Heading 2—only type</h2>
            <p>Paragraph tag 1—we are two</p>
            <p>Paragraph tag 2—we are two</p>
          </div>
        </div><br>

        <!--
        Pseudo-Class :optional
        -->
        <div class="pc-optional">
          <h3>Pseudo-Class :optional</h3>

          <form>
            <div class="field">
              <label for="name" class="required">Name:</label>
              <input type="text" id="name" required>

              <label for="age">Age: (optional)</label>
              <input type="number" id="age" >

              <label for="feedback">Feedback: (optional)</label>
              <input type="text" id="feedback" ><br><br>

              <button type="submit">Submit</button>
            </div>
          </form>
        </div><br>

        <!--
        Pseudo-Class :picture-in-picture
        -->
        <div class="pc-picture-in-picture">
          <h3>Pseudo-Class :picture-in-picture</h3>

          <video id="sample-video" src="../../assets/video/sample-video.mp4" controls=""></video>
          <div class="container">
            <label for="pip-toggle" class="heading">Toggle Picture-in-Picture: </label>
            <input id="pip-toggle" type="checkbox" class="hidden">
            <span id="pip-status" class="hidden">Off</span>
          </div>
          <script>
            const video = document.querySelector("#sample-video");
            const pipToggle = document.querySelector("#pip-toggle");
            const pipStatus = document.querySelector("#pip-status");

            'pictureInPictureEnabled' in document
              ? (pipToggle.classList.remove('hidden'), pipStatus.classList.remove('hidden'))
              : pipToggle.disabled = true;

            pipToggle.addEventListener("change", () => {
              pipStatus.textContent = pipToggle.checked ? "On" : "Off";
              pipToggle.checked ? video.requestPictureInPicture() : document.exitPictureInPicture();
            });
          </script>
        </div><br>

        <!--
        Pseudo-Class :placeholder-shown
        -->
        <div class="pc-placeholder-shown">
          <h3>Pseudo-Class :placeholder-shown</h3>
        </div><br>

        <!--
        Pseudo-Class :read-only
        -->
        <div class="pc-read-only">
          <h3>Pseudo-Class :read-only</h3>
        </div><br>

        <!--
        Pseudo-Class :read-write
        -->
        <div class="pc-read-write">
          <h3>Pseudo-Class :read-write</h3>
        </div><br>

        <!--
        Pseudo-Class :required
        -->
        <div class="pc-required">
          <h3>Pseudo-Class :required</h3>
        </div><br>

        <!--
        Pseudo-Class :right
        -->
        <div class="pc-right">
          <h3>Pseudo-Class :right</h3>
        </div><br>

        <!--
        Pseudo-Class :root
        -->
        <div class="pc-root">
          <h3>Pseudo-Class :root</h3>
        </div><br>

        <!--
        Pseudo-Class :scope
        -->
        <div class="pc-scope">
          <h3>Pseudo-Class :scope</h3>
        </div><br>

        <!--
        Pseudo-Class :target
        -->
        <div class="pc-target">
          <h3>Pseudo-Class :target</h3>
        </div><br>

        <!--
        Pseudo-Class :valid
        -->
        <div class="pc-valid">
          <h3>Pseudo-Class :valid</h3>
        </div><br>

        <!--
        Pseudo-Class :visited
        -->
        <div class="pc-visited">
          <h3>Pseudo-Class :visited</h3>
        </div><br>

        <!--
        Pseudo-Class :where()
        -->
        <div class="pc-where">
          <h3>Pseudo-Class :where()</h3>
        </div><br>

      </article><br><br>

      <!--
      CSS Pseudo-element Selector
      CSS pseudo-element selector is used to style a specific part of an element rather than the element itself.
      The syntax for the pseudo-element selector is as follows:
        a::before {
          content: url();
        }
      -->
      <article class="pseudo-elements">
        <h2>Pseudo Elements</h2>
        <br><br>

        <h3>Content Insertion Pseudo-Elements</h3>
        <p class="content-insertion">Example paragraph: We inserted intro at the start and emoji at the end.</p>
        <br><br>

        <h3>CSS Backdrop Pseudo-Element</h3>
        <dialog id="dialog-box">
          <p>This is a dialog box with a styled backdrop</p>
          <button id="dialog-close">Close</button>
        </dialog>
        <button id="dialog-open">Open Dialog Box</button>
        <script>
          const btnOpen = document.getElementById('dialog-open');
          const btnClose = document.getElementById('dialog-close');
          const dialogBox = document.getElementById('dialog-box');

          btnOpen.addEventListener('click', () => dialogBox.showModal());
          btnClose.addEventListener('click', () => dialogBox.close());
        </script>
        <br><br>

        <h3>CSS Cue Pseudo-Element</h3>
        <!-- TODO: Add CSS Cue Pseudo-Element example here -->
        <br><br>

        <h3>CSS First-Letter Pseudo-Element</h3>
        <p class="f-letter">
          this is a paragraph with first-letter in lower-case;
          we used the ::first-letter pseudo-element to capitalize the first-letter of the paragraph,
          with a larger font size and a different color.
        </p>
        <br><br>

        <h3>CSS First-Line Pseudo-Element</h3>
        <p class="f-line">
          This is a normal paragraph with no styling;
          we used the ::first-line pseudo-element to capitalize the first-line of the paragraph,
          with a background color.
        </p>
        <br><br>

        <h3>CSS File-Selector-Button</h3>
        <h2> Select a file </h2>
        <input type="file" class="select-file">
        <br><br>

        <h3>CSS Marker Pseudo-Element</h3>
        <h2>Numbered list</h2>
        <ol class="list">
          <li>One</li>
          <li>Two</li>
          <li>Three</li>
        </ol>

        <h2>Bulleted list</h2>
        <ul class="list">
          <li>One</li>
          <li>Two</li>
          <li>Three</li>
        </ul>
        <br><br>

        <h3>CSS Placeholder Pseudo-Element</h3>

        <label for="ph-first-name"></label>
        <input type="text" class="placeholder-pe" id="ph-first-name" placeholder="First Name">

        <label for="ph-last-name"></label>
        <input type="text" class="placeholder-pe" id="ph-last-name" placeholder="Last Name">

        <label for="ph-address"></label>
        <input type="text" class="placeholder-pe" id="ph-address" placeholder="Address">

        <label for="ph-phone"></label>
        <input type="text" class="placeholder-pe" id="ph-phone" placeholder="Phone">

        <br><br>

        <h3>CSS Selection Pseudo-Element</h3>
        <br><br>

        <h3>Multiple Pseudo-elements</h3>
        <br><br>

        <h3>All CSS Pseudo-Elements</h3>
        <br><br>

      </article><br><br>

      <!--
      CSS Descendant Selector
      CSS descendant selector styles all the tags which are child of a particular specified tag.
      To mention as descendant, a single space between a parent and child element is used.
      The syntax for the descendant selector is as follows:
        div p {
          color: blue;
        }
      The above code set the text color of paragraph tags that are inside a div element to blue.
      -->
  		<article class="descendant-selectors">
        <h2>Descendant Selectors</h2>
        <p>Example paragraph to be styled by a Child Selector</p>
        <div>
          <p>. This paragraph is a child of a div, child to the article</p>
          <p>. Another happy paragraph that will be styled. Why? Because I am a descendant and not a direct child</p>
        </div>
        <p>Another paragraph to be styled by a Child Selector</p>
      </article><br><br>

      <!--
      CSS Child Selector
      CSS child selector selects all the direct child of a particular element.
      This is denoted by a greater than symbol, >
      The syntax for the child selector is as follows:
        div > p {
          color: blue;
        }
      The above code sets the text color of paragraph tags that are directly inside a div element to blue.
      -->
  		<article class="child-selectors">
        <h2>Child Selectors</h2>
        <p>Example paragraph to be styled by a Child Selector</p>
        <div>
          <p>. This paragraph is a child of a div, child to the article</p>
          <p>. Another sad paragraph that will not be styled. Why? Because I am a descendant and not a direct child</p>
        </div>
        <p>Another paragraph to be styled by a Child Selector</p>
      </article><br><br>

      <!--
      CSS Adjacent Sibling Selectors
      CSS adjacent sibling selector selects an element immediately preceded by a specified element.
      A plus symbol (+) is used to denote an adjacent sibling.
      The syntax of the adjacent sibling selector is as follows:
        h1 + p {
          margin-top: 0;
        }
      The above code sets the top margin of the paragraph tag just after h1 tag to 0.
      -->
  		<article class="adjacent-sibling-selectors">
        <h2>Adjacent Sibling Selectors</h2>
        <p>This paragraph is above the div and WILL NOT be blue</p>
        <div>
           <p>This paragraph is inside a div and will not be blue.</p>
        </div>
        <p>This paragraph 1 after the div and will be blue.</p>
        <p>This paragraph 2 after the div and WILL NOT be blue.</p>
      </article><br><br>

      <!--
      CSS General Sibling Selector
      CSS general sibling selector targets all the element that is preceded by a specified element.
      The general sibling selector is denoted by a tilde symbol ~
      The syntax of general sibling selector is as follows:
        h1 ~ p {
          color: gray;
        }
      The above code sets the text color of all the paragraphs after h1 tag to gray.
      -->
      <article class="general-sibling-selectors">
        <h2>General Sibling Selectors</h2>
        <p>This paragraph is above the div and WILL NOT be blue</p>
        <div>
           <p>This paragraph is inside a div and will not be blue.</p>
        </div>
        <p>This paragraph 1 after the div and will be blue.</p>
        <p>This paragraph 2 after the div and will be blue.</p>
      </article><br><br>

		</section><hr>

		<!--
		-->
		<section>
			<h1>Colors</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Color</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Backgrounds</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Fonts</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Text</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Text</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Images</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Image Gallery</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Icons</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Links</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Tables</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Lists</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Borders</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Rounded Corner</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Padding</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Margins</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Box Model</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Display</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Inline Block</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Cursor</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Outlines</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Data Types</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>All</h1>
		</section><hr>

		<!--
		-->
		<section>
			<h1>Root</h1>
		</section><hr>

	</main>

</body>
</html>
